function readFile() {
	let input = document.getElementById('file-input')
	let file = input.files[0]
	let reader = new FileReader()
	reader.readAsText(file, 'UTF-8')
	reader.onload = () => {
		var fileContent = reader.result
		let editor = getCurrentAceEditor()
		let doc = editor.env.document.doc
		if (doc !== null || doc !== undefined) {
			doc.setValue(fileContent)
			let fileName = document.getElementById('fileName');
			fileName.value = file.name
			localStorage.setItem("fileName", file.name)
		}
	}
}

function printChildren(a) {
	let s = "";
	a.forEach((element) => {
		s = s + element.getFieldValue("TEXT");
	})
	return s;
}

function onDocumentChange() {
	let editor = getCurrentAceEditor()
	let document = editor.env.document.doc
	let fileContent = document.getValue()
	localStorage.setItem(editor.container.id + "fileContent", fileContent)
}

function getSavedDocument(editor) {
	let doc = editor.env.document.doc
	let editorId = editor.container.id
	let fileContent = localStorage.getItem(editorId + "fileContent");
	if (fileContent !== null) {
		doc.insert({ row: 0, column: 0 }, fileContent)
	}
	let fileName = localStorage.getItem(editorId + "fileName")
	if (fileContent !== null) {
		let fileNameElement = document.getElementById(editorId + 'fileName');
		if (fileNameElement !== null)
			fileNameElement.value = fileName
	}
}

let entities = document.getElementById('xtext-editor-entities')
let entitiesTab = document.getElementById('entity-tab')
let entitiesBlock = document.getElementById('blockly-editor')
let scenario = document.getElementById('xtext-editor-scenarios')
let scenarioTab = document.getElementById('scenario-tab')
let scenarioBlock = document.getElementById('blockly-editor2')
let warningMessage = document.getElementById('warning-message')
let originalToolbox;
let entitiesToolboxInjected = false;
let scenarioToolboxInjected = false;
let scenarioWorkspace;
let entityWorkspace;
let blockArray;
let autoGeneratedEntityBlocks = false;
let autoGeneratedScenarioBlocks = false;
let currentAst;
let currentTab = entitiesTab;
let currentBlockly = entitiesBlock;
let enabledByText = false;
let enabledByCodeBlocks = false;

const runCodeForEntity = (element) => {
	if (entitiesToolboxInjected && element === entitiesTab && !autoGeneratedEntityBlocks)
	{
		let entityCode = getBddGenerator(blockArray).workspaceToCode(entityWorkspace);

		entityCode = entityCode.replaceAll('declarative entity', '\n declarative entity');
		entityCode = entityCode.replaceAll('imperative entity', '\n imperative entity');
		entityCode = entityCode.replaceAll('actions:', '\n actions:');
		entityCode = entityCode.replaceAll('states:', '\n states:');
		entityCode = entityCode.replaceAll('properties:', '\n properties:');


		let editor = getCurrentAceEditor()
		let doc = editor.env.document.doc
		if (doc !== null || doc !== undefined) {
			doc.setValue(entityCode.replace(/^\s*$\n?/gm, '').replace(/ +/g, ' ')); // removes blank lines & multiple spaces
			autoGeneratedEntityBlocks = false;
		}
	}	
};

const runCodeForScenario = (element) => {
	if (scenarioToolboxInjected && element === scenarioTab && !autoGeneratedScenarioBlocks)
	{
		console.log("runCodeForScenario");
		let scenarioCode = getBddGenerator(blockArray).workspaceToCode(scenarioWorkspace);
		
		scenarioCode = scenarioCode.replaceAll('Scenario:', '\n Scenario:');
		scenarioCode = scenarioCode.replaceAll('Given', '\n Given');
		scenarioCode = scenarioCode.replaceAll('When', '\n When');
		scenarioCode = scenarioCode.replaceAll('Then', '\n Then');
		scenarioCode = scenarioCode.replaceAll('And', '\n And');
		
		let editor = getCurrentAceEditor()
		let doc = editor.env.document.doc
		if (doc !== null || doc !== undefined) {
			doc.setValue(scenarioCode.replace(/^\s*$\n?/gm, '').replace(/ +/g, ' ')); // removes blank lines & multiple spaces	
			autoGeneratedScenarioBlocks = false;
		}
	}	
};

function displayEditor(currEditor, newEditor, currBlockly, newBlockly) {
	currEditor.style.display = "none"
	currBlockly.style.display = "none"
	newEditor.style.display = "block"
	newBlockly.style.display = "block"
}

function switchEditor(e) {
	if (e.target.disabled)
		return;

	var b = ""
	if (e.target != currentTab) {
		removeSelectionBorder(currentTab)
		let editorId = e.target.dataset.editorId

		if (editorId == "xtext-editor-entities") { b = "blockly-editor" }
		else if (editorId == "xtext-editor-scenarios") { b = "blockly-editor2" }

		let editor = document.getElementById(editorId)
		let blockly = document.getElementById(b)
		displayEditor(currentEditor, editor, currentBlockly, blockly)
		currentEditor = editor
		currentTab = e.target
		currentBlockly = blockly
		setSelectionBorder(currentTab)
    	loadBlocks(currentTab, true);
	}
}

function onEntityEditorChange() {
	if (entities.innerText != null && entities.innerText.replace(/[^a-zA-Z]/g, '').trim() !== '') {
		setEnabled(scenarioTab);
		enabledByText = true;

		fetch('/xtext-service/ast?resource=multi-resource/scenarios.bdd')
			.then(response => response.json())
			.then(response => {
				autoGeneratedEntityBlocks = true;
				if (currentAst !== response.ast)
				{
					generateBlocksFromAst(response.ast, entityWorkspace, blockArray, 'entities');
					currentAst = response.ast;
				}
			});
	}
	else if (!enabledByCodeBlocks) {
		setDisabled(scenarioTab);
		enabledByText = false;
	}
}

function onScenarioEditorChange() {
	fetch('/xtext-service/ast?resource=multi-resource/scenarios.bdd')
		.then(response => response.json())
		.then(response => {
			autoGeneratedScenarioBlocks = true;
			if (currentAst !== response.ast)
			{
				generateBlocksFromAst(response.ast, scenarioWorkspace, blockArray, 'scenarios');
				currentAst = response.ast;
			}
		});
}

function setSelectionBorder(element) {
	element.style.border = "2px black solid";
}

function removeSelectionBorder(element) {
	element.style.border = "2px white solid"
}

function setDisabled(element) {
	element.style.backgroundColor = "#f2f2f2";
	element.style.pointerEvents = "none";
	element.disabled = true;
	warningMessage.style.visibility = "visible";
}

function setEnabled(element) {
	element.style.backgroundColor = "#ddd";
	element.style.pointerEvents = "auto";
	element.disabled = false;
	warningMessage.style.visibility = "hidden";
}

if (entitiesTab != undefined)
	entitiesTab.onclick = switchEditor
if (scenarioTab != undefined)
	scenarioTab.onclick = switchEditor

setEnabled(entitiesTab);
setSelectionBorder(entitiesTab);

window.onload = () => {
  setTimeout (() => {
	currentEditor = entities;
    for (let editor of editors) {
      getSavedDocument(editor)
      let document = editor.env.document.doc
      document.on('change', onDocumentChange)
    }
    let input = document.getElementById('file-input')
    input.addEventListener('change', readFile) 

    loadBlocks(currentTab, false);
	onEntityEditorChange();
  }, 200)
}


//let astBtn = document.getElementById('get-ast')
//astBtn.onclick = () => {
//	fetch('/xtext-service/ast?resource=multi-resource/scenarios.bdd')
//		.then(response => response.json())
//		.then(response => {
//			console.log(response);
//			console.log(JSON.stringify(response));
//		})
//}

function loadBlocks(element, skipAddingBlocks) {
	fetch('/xtext-service/blocks?resource=multi-resource/scenarios.bdd')
		.then(response => response.json())
		.then(response => {
			response.blocks = JSON.parse(response.blocks)
			response.toolBox = JSON.parse(response.toolBox)
			blockArray = response.blocks

      		if (!skipAddingBlocks)
			  Blockly.defineBlocksWithJsonArray(response.blocks)

			let id_validator = function(newValue) {
				//if it returns '', then the input is correct
				let res = newValue.replace(/[\^a-zA-Z_][a-zA-Z_0-9]*/g, '')

				if (res == '') {
					return undefined;
				}
				return null;
			}
			
			//if ID block
			Blockly.Blocks["ID"] = {
				init: function() {
					this.setColour(200)
					this.setOutput(true, 'ID')
					this.appendDummyInput()
						.appendField(new Blockly.FieldTextInput('ID', id_validator), 'TEXT_INPUT');

				}
			}

			let string_validator = function(newValue) {

				let res = newValue.replace(/[^\"]*/g, '')
				if (res == '') {
					return undefined;
				}
				return null;
			}

			//if string block
			Blockly.Blocks["STRING"] = {
				init: function() {
					this.setColour(300)
					this.setOutput(true, 'STRING')
					this.appendDummyInput()
						.appendField("\"")
						.appendField(new Blockly.FieldTextInput('String', string_validator), 'TEXT_INPUT')
						.appendField("\"");
				}
			}

			let termArr = []
			termArr.push({ "kind": "block", "type": "ID" })
			termArr.push({ "kind": "block", "type": "STRING" })

			response.toolBox.contents.push({ "kind": "category", "name": "Terminals", contents: termArr })

			//Debugging toolbox
			let debugArr = []
			debugArr.push({ "kind": "block", "type": "DebugStatement" });  // Add debug_to begin debuggin block here
			response.toolBox.contents.push({ "kind": "category", "name": "Debugging", contents: debugArr })
			
      		originalToolbox = response.toolBox;
			response.toolBox.contents = filterCategories(element, originalToolbox.contents);

			if (element === scenarioTab && !scenarioToolboxInjected)
			{
				scenarioWorkspace = Blockly.inject("blockly-editor2", { "toolbox": response.toolBox });
				scenarioToolboxInjected = true;
			}

			if (element === entitiesTab && !entitiesToolboxInjected)
			{
				entityWorkspace = Blockly.inject("blockly-editor", { "toolbox": response.toolBox });
				entitiesToolboxInjected = true;
			}

			if (entities != undefined) {
				entities.addEventListener("input", onEntityEditorChange);
			}

			if (scenario != undefined) {
				scenario.addEventListener("input", onScenarioEditorChange);
			}

			function onEntityWorkspaceChange(event) {
				var scenarioTabElement = document.getElementById('scenario-tab')

				if (entityWorkspace.getAllBlocks().length > 0) {
					setEnabled(scenarioTabElement);
					enabledByCodeBlocks = true;
				}
				else if (!enabledByText) {
					setDisabled(scenarioTabElement);
					enabledByCodeBlocks = false;
				}

				if (event.type == 'drag' || event.entityCode === 'selected') {
					autoGeneratedEntityBlocks = false;					
				}
				
				if (element === entitiesTab)
					runCodeForEntity(element);
			}

			function onScenarioWorkspaceChange(event) {
				if (event.type == 'drag' || event.entityCode === 'selected') {
					autoGeneratedScenarioBlocks = false;					
				}

				if (element === scenarioTab)
					runCodeForScenario(element);
			}

      		if (entityWorkspace !== undefined) {
				entityWorkspace.addChangeListener(onEntityWorkspaceChange);
			}

      		if (scenarioWorkspace !== undefined) {
				scenarioWorkspace.addChangeListener(onScenarioWorkspaceChange);
			}
		})
}

function filterCategories(element, contents) {
	if (element === entitiesTab) {
		let categories = ["Declarative Scenarios", "Imperative Scenarios"];
		return contents.filter(item => !categories.includes(item.name));
	}
	else if (element === scenarioTab) {
		let categories = ["Declarative Entities", "Imperative Entities"];
		return contents.filter(item => !categories.includes(item.name));
	}
}

function saveScenario() {
  const scenarioEditor = ace.edit("xtext-editor-scenarios");
  const scenarioContent = scenarioEditor.getValue();

  appendToConsole(`${scenarioContent}!\n`);

  // Save the scenario content
  fetch('/save-scenario', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: scenarioContent })
  })
  .then(response => {
    if (response.ok) {
      appendToConsole('Scenario saved successfully!\n', 'console-output', 'success');
    } else {
      appendToConsole('Error saving scenario.\n', 'console-output', 'error');
    }
  })
  .catch(error => {
    appendToConsole('Error: An error occurred while saving the scenario.\n', 'console-output', 'error');
  });
}

function saveEntities() {
  const entitiesEditor = ace.edit("xtext-editor-entities");
  const entitiesContent = entitiesEditor.getValue();
  
  appendToConsole(`${entitiesContent}!\n`);

  // Save the entities content
  fetch('/save-entities', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: entitiesContent })
  })
  .then(response => {
    if (response.ok) {
      appendToConsole('Entities saved successfully!\n', 'console-output', 'success');
    } else {
      appendToConsole('Error saving entities.\n', 'console-output', 'error');
    }
  })
  .catch(error => {
    appendToConsole('Error: An error occurred while saving the entities.\n', 'console-output', 'error');
  });
}



document.addEventListener('DOMContentLoaded', function() {
    // Initialize console
    const consoleOutput = document.getElementById('console-output');
    const clearConsoleButton = document.getElementById('clear-console');

    // Clear console button functionality
    clearConsoleButton.addEventListener('click', function() {
        consoleOutput.textContent = '';
    });

    // Add initial message
    appendToConsole('Console ready. Click "Run Scenario" to begin.\n', 'console-output', 'info');
	appendToConsole('Either add a "pause" block to a scenario or write pause at the end of a line to begin debugging. Then click "Run Scenario". \n', 'debug-output', 'info');
});


function clearDebugConsole(){
	document.getElementById('debug-output').textContent = '';
}

function clearOutputConsole(){
	document.getElementById('console-output').textContent = '';
}



function appendToConsole(message, output='console-output', type ='info') {
    const consoleOutput = document.getElementById(output);
   
	// Create a new div for the message
	const messageElement = document.createElement('div');

	// Add appropriate classes for styling
	messageElement.classList.add('console-message', type);
	
	// Set the message text
	messageElement.textContent = message;

	 // Append the message to the output
  	consoleOutput.appendChild(messageElement);

	// Auto-scroll to the bottom
	consoleOutput.scrollTop = consoleOutput.scrollHeight;
}

function stepOnclick() {
	globalWebsocketPointer.send('1');
}

function continueOnclick() {
	globalWebsocketPointer.send('');
	toggleDebugButtons();
}

function stopOnclick() {
	globalWebsocketPointer.close();
}

function toggleDebugButtons(){
	const cont = document.getElementById('continue-btn');
	const step = document.getElementById('step-btn');
	cont.disabled = !cont.disabled;
	step.disabled = !step.disabled;
}

function toggleRunStopButtons(){
	const runScenario = document.getElementById('run-scenario');
	const stop = document.getElementById('stop-btn');
	runScenario.disabled 	= !runScenario.disabled;
	stop.disabled 			= !stop.disabled;
}

var globalWebsocketPointer;

// Utility function to remove paths from a string
function removePathFromLine(line) {
    // Check if the line contains the pattern "# ../"
    if (line.includes("# ../")) {
        const beforePath = line.split('#')[0].trim(); // Text before the path
        const afterPath = line.split('#')[1].split(':').slice(1).join(':').trim(); // Text after the path
        return `${beforePath} ${afterPath}`.trim(); // Combine and return
    }
    return line; // Return unmodified if no path is found
}


function runScenarioInteractive() {
	saveScenario()
	saveEntities()
    const websocket = new WebSocket('ws://localhost:8081/run-scenario-interactive'); // Use ws:// for non-secure, wss:// for secure connections
    globalWebsocketPointer = websocket;
	appendToConsole('Starting scenario execution...\n', 'console-output', 'info');
	toggleRunStopButtons();
  
	websocket.onmessage = function (event) {
	    // Initialize the context buffer if not already done
	    if (!window.contextBuffer) {
	        window.contextBuffer = ''; // Buffer to accumulate context data
	    }

	    // Remove paths from the incoming data
	    const cleanData = removePathFromLine(event.data);
		
	    // Extract stepmode from event.data
	    const stepmodeMatch = event.data.match(/step_mode=(\d)/);
	    if (stepmodeMatch) {
	        stepmode = parseInt(stepmodeMatch[1], 10); // Extract stepmode as an integer
	    }

	    // Check for end-of-context marker
	    if (event.data.includes("EOC")) {
	        // Process the accumulated context data
	        let fullContext = window.contextBuffer.replace("EOC", "").trim();
			fullContext = fullContext.replace(/step_mode=\d/, "").trim(); // Remove step_mode and trim whitespace
			fullContext = fullContext.replace(/pausetag/, "").trim();
	        // Append full context to the appropriate console based on stepmode
	        if (stepmode === 1 || stepmode === 2) {
	            appendToConsole(fullContext + '\n', 'debug-output', 'info');
	        } else if (stepmode === 0) {
	            appendToConsole(fullContext + '\n', 'console-output', 'info');
	        }

	        // Clear the context buffer
	        window.contextBuffer = '';
	    } else {
	        // Accumulate data into the buffer if it's part of a context
	        window.contextBuffer += cleanData + '\n';

	        // Handle other conditions when not accumulating
	        if (event.data.includes("../")) {
	            updateDebugScenarioVisuals(event.data);
	        } else if (event.data.includes("pausetag")) {
	            if (document.getElementById('continue-btn').disabled)
	                toggleDebugButtons();
	        } else if (event.data.includes("Took ")) {
				appendToConsole(window.contextBuffer + '\n', 'console-output', 'info');
	            websocket.close();
	        }
	    }
	};

    websocket.onclose = function(event) {
		toggleRunStopButtons();
		if (!document.getElementById('continue-btn').disabled)
		            	toggleDebugButtons();
		updateDebugScenarioVisuals('');
		latestLinenumber = -1;
        appendToConsole('Execution completed\n', 'console-output', 'info');  
    };

    websocket.onerror = function(error) {
        appendToConsole('Error: Connection to server lost\n', 'console-output', 'error');
        websocket.close();
    };
}

// Find the target element
const textLayer = document.querySelector('.ace_layer.ace_text-layer');

// comment
var latestLinenumber = -1;

function updateDebugScenarioVisuals(linetext) {
	const textLayer = document.querySelector('.ace_layer.ace_text-layer');
	if (textLayer) {
		// Get all child elements of the text layer
		const children = textLayer.children;
		
		for (let i = 0; i < children.length; i++) {
		    const child = children[i];
			child.style.backgroundColor = ''; // reset child by default
			if (child.textContent.trim() != '' && linetext.includes(child.textContent.trim()) && i > latestLinenumber) {
				child.style.backgroundColor = 'rgba(127, 255, 0, 0.5)';
				latestLinenumber = i; 
				break;
			}
		}
	}
}

document.addEventListener('DOMContentLoaded', function() {
          initializeVersionControl();
      });

	  
	  function toggleVersionPanel() {
	    const panel = document.querySelector('.version-control-panel');
	    panel.classList.toggle('collapsed');
	
	  }
	
	  function initializeVersionControl() {
	      document.getElementById('save-version').addEventListener('click', saveVersion);
	      listVersions();
	  }
	
	  async function listVersions() {
	      try {
	          const response = await fetch('/list-versions');
	          const versions = await response.json();
	          
	          const versionsContainer = document.getElementById('versions-list');
	          versionsContainer.innerHTML = '';
	          
	          versions.forEach(version => {
	              const versionElement = createVersionElement(version);
	              versionsContainer.appendChild(versionElement);
	          });
	          
	          appendToConsole("Versions loaded successfully.\n",'console-output','success');
	      } catch (error) {
	          appendToConsole(`Error loading versions: ${error.message}\n`,'console-output','error');
	      }
	  }
	
	  function createVersionElement(version) {
	      let dateString = version.metadata?.createdAt;
	      if (!dateString) {
	          dateString = version.metadata?.timestamp;
	          if (dateString) {
	              // Parse the custom timestamp string into a Date object
	              const year = parseInt(dateString.substring(0, 4));
	              const month = parseInt(dateString.substring(4, 6)) - 1; // Month is 0-indexed
	              const day = parseInt(dateString.substring(6, 8));
	              const hour = parseInt(dateString.substring(9, 11));
	              const minute = parseInt(dateString.substring(11, 13));
	              const second = parseInt(dateString.substring(13, 15));
	              dateString = new Date(year, month, day, hour, minute, second).toISOString();
	          } else {
	              dateString = version.lastModified; // Fallback if both custom and createdAt are missing
	          }
	      }
	      const date = new Date(dateString); // Create date object once
	
	      const fileName = version.metadata?.fileName || 'Unnamed';
	      const folderName = version.folderName || 'Unversioned';
	
	      const versionDiv = document.createElement('div');
	      versionDiv.className = 'version-item';
	      versionDiv.dataset.version = version.folderName;
	
	      versionDiv.innerHTML = `
	          <div class="version-item-header">
	              <div class="version-info">
	                  <div class="version-name">${fileName}</div>
	                  <div class="version-timestamp">
	                      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
	                          <circle cx="12" cy="12" r="10"/>
	                          <path d="M12 6v6l4 2"/>
	                      </svg>
	                      ${date.toLocaleString()}
	                  </div>
	              </div>
	              <div class="version-actions">
	                  <button class="action-button revert-button" onclick="revertToVersion('${version.folderName}')">
	                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
	                          <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
	                          <path d="M3 3v5h5"/>
	                      </svg>
	                      Revert
	                  </button>
	                  <button class="action-button delete-button" onclick="deleteVersion('${version.folderName}')">
	                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
	                          <path d="M3 6h18"/>
	                          <path d="M6 6v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V6"/>
	                          <path d="M9 6V4a3 3 0 0 1 6 0v2"/>
	                      </svg>
	                      Delete
	                  </button>
	              </div>
	          </div>
	      `;          
	      return versionDiv;
	  }
	
	  async function revertToVersion(versionFileName) {
	      if (!versionFileName) {
	          appendToConsole("No version selected for revert.\n", 'console-output', 'info');
	          return;
	      }
	
	      try {
	          const response = await fetch('/revert-version', {
	              method: 'POST',
	              headers: {
	                  'Content-Type': 'application/json'
	              },
	              body: JSON.stringify({ versionFileName })
	          });
	
	          const result = await response.json();
	
	          if (response.ok) {
	              appendToConsole(`Reverted to version: ${versionFileName}\n`);
	              
	              if (result.contentScenario && result.contentEntities) {
	                  const editorScenario = getScenarioAceEditor();
	                  editorScenario.setValue(result.contentScenario);
	                  editorScenario.clearSelection();
	
	                  const editorEntities = getEntitiesAceEditor();
	                  editorEntities.setValue(result.contentEntities);
	                  editorEntities.clearSelection();
	              }
				  // Update the file name input field with the fileName from metadata
				  if (result.metadata && result.metadata.fileName) {
				      document.getElementById('fileName').value = result.metadata.fileName;
				  } else {
				      document.getElementById('fileName').value = 'Unnamed Scenario';
				  }
	
	
	              document.querySelectorAll('.version-item').forEach(item => {
	                  item.classList.remove('selected');
	                  if (item.dataset.version === versionFileName) {
	                      item.classList.add('selected');
	                  }
	              });
	              
	              await listVersions();
	          } else {
	              appendToConsole(`Failed to revert to version: ${result.message}\n`, 'console-output', 'error');
	          }
	      } catch (error) {
	          appendToConsole(`Error reverting version: ${error.message}\n`, 'console-output', 'error');
	      }
	  }
	  
	  async function deleteVersion(versionFolderName) {
	      if (!versionFolderName) {
	          appendToConsole("No version selected for deletion.\n");
	          return;
	      }
	
	      if (!confirm(`Are you sure you want to delete version: ${versionFolderName}?`)) {
	          return;
	      }
	
	      try {
	          const response = await fetch('/delete-version', {
	              method: 'POST',
	              headers: {
	                  'Content-Type': 'application/json'
	              },
	              body: JSON.stringify({ versionFolderName })
	          });
	
	          const result = await response.json();
	
	          if (response.ok) {
	              appendToConsole(`Deleted version: ${versionFolderName}\n`);
	              await listVersions();
	          } else {
	              appendToConsole(`Failed to delete version: ${result.message}\n`);
	          }
	      } catch (error) {
	          appendToConsole(`Error deleting version: ${error.message}\n`);
	      }
	  }
	
	
	  async function saveVersion() {
	      const editorScenario = getScenarioAceEditor(); // Function to get scenario editor
	      const contentScenario = editorScenario.getValue();
	      
	      const editorEntities = getEntitiesAceEditor(); // Function to get entities editor
	      const contentEntities = editorEntities.getValue();
	      
	      const metadata = {
	          fileName: document.getElementById("fileName").value || 'Unnamed Scenario',
	          timestamp: new Date().toISOString()
	      };
		  const payload = { contentScenario, contentEntities, metadata }; // Prepare payload
	
		  // Log the payload to the console
		  console.log("Payload to /save-both:", JSON.stringify(payload, null, 2));
		  appendToConsole(`Payload to be sent: ${JSON.stringify(payload, null, 2)}\n`, 'console-output', 'info');
	
		  try {
		      const response = await fetch('/save-both', {
		          method: 'POST',
		          headers: {
		              'Content-Type': 'application/json'
		          },
		          body: JSON.stringify(payload)
		      });
	
		      if (response.ok) {
		          const result = await response.json();
		          appendToConsole(`Version saved successfully: ${result.version}\n`, 'console-output', 'success');
		          await listVersions();
		      } else {
		          const error = await response.text();
		          appendToConsole(`Failed to save version: ${error}\n`, 'console-output', 'error');
		      }
		  } catch (error) {
		      appendToConsole(`Error: ${error.message}\n`, 'console-output', 'error');
		  }
	  }
	  function getScenarioAceEditor() {
		return ace.edit("xtext-editor-scenarios");
	  }
	
	  function getEntitiesAceEditor() {
		return ace.edit("xtext-editor-entities"); 
	  }