function readFile() {
	let input = document.getElementById('file-input')
	let file = input.files[0]
	let reader = new FileReader()
	reader.readAsText(file, 'UTF-8')
	reader.onload = () => {
		var fileContent = reader.result
		let editor = getCurrentAceEditor()
		let doc = editor.env.document.doc
		if (doc !== null || doc !== undefined) {
			doc.setValue(fileContent)
			let fileName = document.getElementById('fileName');
			fileName.value = file.name
			localStorage.setItem("fileName", file.name)
		}
	}
}

function printChildren(a) {
	let s = "";
	a.forEach((element) => {
		s = s + element.getFieldValue("TEXT");
	})
	return s;
}

function onDocumentChange() {
	let editor = getCurrentAceEditor()
	let document = editor.env.document.doc
	let fileContent = document.getValue()
	localStorage.setItem(editor.container.id + "fileContent", fileContent)
}

function getSavedDocument(editor) {
	let doc = editor.env.document.doc
	let editorId = editor.container.id
	let fileContent = localStorage.getItem(editorId + "fileContent");
	if (fileContent !== null) {
		doc.insert({ row: 0, column: 0 }, fileContent)
	}
	let fileName = localStorage.getItem(editorId + "fileName")
	if (fileContent !== null) {
		let fileNameElement = document.getElementById(editorId + 'fileName');
		if (fileNameElement !== null)
			fileNameElement.value = fileName
	}
}

let entities = document.getElementById('xtext-editor-entities')
let entitiesTab = document.getElementById('entity-tab')
let entitiesBlock = document.getElementById('blockly-editor')
let scenario = document.getElementById('xtext-editor-scenarios')
let scenarioTab = document.getElementById('scenario-tab')
let scenarioBlock = document.getElementById('blockly-editor2')
let warningMessage = document.getElementById('warning-message')
let originalToolbox;
let entitiesToolboxInjected = false;
let scenarioToolboxInjected = false;
let scenarioWorkspace;
let entityWorkspace;
let blockArray;
let autoGeneratedEntityBlocks = false;
let autoGeneratedScenarioBlocks = false;
let currentAst;
let currentTab = entitiesTab;
let currentBlockly = entitiesBlock;
let enabledByText = false;
let enabledByCodeBlocks = false;

const runCodeForEntity = (element) => {
	if (entitiesToolboxInjected && element === entitiesTab && !autoGeneratedEntityBlocks)
	{
		console.log("runCodeForEntity");
		let entityCode = getBddGenerator(blockArray).workspaceToCode(entityWorkspace);

		entityCode = entityCode.replaceAll('declarative entity', '\n declarative entity');
		entityCode = entityCode.replaceAll('imperative entity', '\n imperative entity');
		entityCode = entityCode.replaceAll('actions:', '\n actions:');
		entityCode = entityCode.replaceAll('states:', '\n states:');
		entityCode = entityCode.replaceAll('properties:', '\n properties:');
		// console.log(entityCode);

		let editor = getCurrentAceEditor()
		let doc = editor.env.document.doc
		if (doc !== null || doc !== undefined) {
			doc.setValue(entityCode.replace(/^\s*$\n?/gm, '').replace(/ +/g, ' ')); // removes blank lines & multiple spaces
			autoGeneratedEntityBlocks = false;
		}
	}	
};

const runCodeForScenario = (element) => {
	if (scenarioToolboxInjected && element === scenarioTab && !autoGeneratedScenarioBlocks)
	{
		console.log("runCodeForScenario");
		let scenarioCode = getBddGenerator(blockArray).workspaceToCode(scenarioWorkspace);
		
		scenarioCode = scenarioCode.replaceAll('Scenario:', '\n Scenario:');
		scenarioCode = scenarioCode.replaceAll('Given', '\n Given');
		scenarioCode = scenarioCode.replaceAll('When', '\n When');
		scenarioCode = scenarioCode.replaceAll('Then', '\n Then');
		scenarioCode = scenarioCode.replaceAll('And', '\n And');
		
		let editor = getCurrentAceEditor()
		let doc = editor.env.document.doc
		if (doc !== null || doc !== undefined) {
			doc.setValue(scenarioCode.replace(/^\s*$\n?/gm, '').replace(/ +/g, ' ')); // removes blank lines & multiple spaces	
			autoGeneratedScenarioBlocks = false;
		}
	}	
};

function displayEditor(currEditor, newEditor, currBlockly, newBlockly) {
	currEditor.style.display = "none"
	currBlockly.style.display = "none"
	newEditor.style.display = "block"
	newBlockly.style.display = "block"
}

function switchEditor(e) {
	if (e.target.disabled)
		return;

	var b = ""
	if (e.target != currentTab) {
		removeSelectionBorder(currentTab)
		let editorId = e.target.dataset.editorId

		if (editorId == "xtext-editor-entities") { b = "blockly-editor" }
		else if (editorId == "xtext-editor-scenarios") { b = "blockly-editor2" }

		let editor = document.getElementById(editorId)
		let blockly = document.getElementById(b)
		displayEditor(currentEditor, editor, currentBlockly, blockly)
		currentEditor = editor
		currentTab = e.target
		currentBlockly = blockly
		setSelectionBorder(currentTab)
    	loadBlocks(currentTab, true);
	}
}

function onEntityEditorChange() {
	if (entities.innerText != null && entities.innerText.replace(/[^a-zA-Z]/g, '').trim() !== '') {
		setEnabled(scenarioTab);
		enabledByText = true;

		fetch('/xtext-service/ast?resource=multi-resource/scenarios.bdd')
			.then(response => response.json())
			.then(response => {
				autoGeneratedEntityBlocks = true;
				if (currentAst !== response.ast)
				{
					generateBlocksFromAst(response.ast, entityWorkspace, blockArray, 'entities');
					currentAst = response.ast;
				}
			});
	}
	else if (!enabledByCodeBlocks) {
		setDisabled(scenarioTab);
		enabledByText = false;
	}
}

function onScenarioEditorChange() {
	fetch('/xtext-service/ast?resource=multi-resource/scenarios.bdd')
		.then(response => response.json())
		.then(response => {
			autoGeneratedScenarioBlocks = true;
			if (currentAst !== response.ast)
			{
				generateBlocksFromAst(response.ast, scenarioWorkspace, blockArray, 'scenarios');
				currentAst = response.ast;
			}
		});
}

function setSelectionBorder(element) {
	element.style.border = "2px black solid";
}

function removeSelectionBorder(element) {
	element.style.border = "2px white solid"
}

function setDisabled(element) {
	element.style.backgroundColor = "#f2f2f2";
	element.style.pointerEvents = "none";
	element.disabled = true;
	warningMessage.style.visibility = "visible";
}

function setEnabled(element) {
	element.style.backgroundColor = "#ddd";
	element.style.pointerEvents = "auto";
	element.disabled = false;
	warningMessage.style.visibility = "hidden";
}

if (entitiesTab != undefined)
	entitiesTab.onclick = switchEditor
if (scenarioTab != undefined)
	scenarioTab.onclick = switchEditor

setEnabled(entitiesTab);
setSelectionBorder(entitiesTab);

window.onload = () => {
  setTimeout (() => {
	currentEditor = entities;
    for (let editor of editors) {
      getSavedDocument(editor)
      let document = editor.env.document.doc
      document.on('change', onDocumentChange)
    }
    let input = document.getElementById('file-input')
    input.addEventListener('change', readFile) 

    loadBlocks(currentTab, false);
	onEntityEditorChange();
  }, 200)
}

let astBtn = document.getElementById('get-ast')
astBtn.onclick = () => {
	fetch('/xtext-service/ast?resource=multi-resource/scenarios.bdd')
		.then(response => response.json())
		.then(response => {
			console.log(response);
			console.log(JSON.stringify(response));
		})
}

function loadBlocks(element, skipAddingBlocks) {
	fetch('/xtext-service/blocks?resource=multi-resource/scenarios.bdd')
		.then(response => response.json())
		.then(response => {
			// console.log(response)
			response.blocks = JSON.parse(response.blocks)
			response.toolBox = JSON.parse(response.toolBox)
			blockArray = response.blocks

      		if (!skipAddingBlocks)
			  Blockly.defineBlocksWithJsonArray(response.blocks)

			let id_validator = function(newValue) {
				//if it returns '', then the input is correct
				let res = newValue.replace(/[\^a-zA-Z_][a-zA-Z_0-9]*/g, '')

				if (res == '') {
					return undefined;
				}
				return null;
			}

			Blockly.Blocks["ID"] = {
				init: function() {
					this.setColour(200)
					this.setOutput(true, 'ID')
					this.appendDummyInput()
						.appendField(new Blockly.FieldTextInput('ID', id_validator), 'TEXT_INPUT');

				}
			}

			let string_validator = function(newValue) {

				let res = newValue.replace(/[^\"]*/g, '')
				if (res == '') {
					return undefined;
				}
				return null;
			}


			Blockly.Blocks["STRING"] = {
				init: function() {
					this.setColour(300)
					this.setOutput(true, 'STRING')
					this.appendDummyInput()
						.appendField("\"")
						.appendField(new Blockly.FieldTextInput('String', string_validator), 'TEXT_INPUT')
						.appendField("\"");
				}
			}

			let termArr = []
			termArr.push({ "kind": "block", "type": "ID" })
			termArr.push({ "kind": "block", "type": "STRING" })

			response.toolBox.contents.push({ "kind": "category", "name": "Terminals", contents: termArr })

      		originalToolbox = response.toolBox;
			response.toolBox.contents = filterCategories(element, originalToolbox.contents);

			if (element === scenarioTab && !scenarioToolboxInjected)
			{
				scenarioWorkspace = Blockly.inject("blockly-editor2", { "toolbox": response.toolBox });
				scenarioToolboxInjected = true;
			}

			if (element === entitiesTab && !entitiesToolboxInjected)
			{
				entityWorkspace = Blockly.inject("blockly-editor", { "toolbox": response.toolBox });
				entitiesToolboxInjected = true;
			}

			if (entities != undefined) {
				entities.addEventListener("input", onEntityEditorChange);
			}

			if (scenario != undefined) {
				scenario.addEventListener("input", onScenarioEditorChange);
			}

			function onEntityWorkspaceChange(event) {
				var scenarioTabElement = document.getElementById('scenario-tab')

				if (entityWorkspace.getAllBlocks().length > 0) {
					setEnabled(scenarioTabElement);
					enabledByCodeBlocks = true;
				}
				else if (!enabledByText) {
					setDisabled(scenarioTabElement);
					enabledByCodeBlocks = false;
				}

				if (event.type == 'drag' || event.entityCode === 'selected') {
					autoGeneratedEntityBlocks = false;					
				}
				
				if (element === entitiesTab)
					runCodeForEntity(element);
			}

			function onScenarioWorkspaceChange(event) {
				if (event.type == 'drag' || event.entityCode === 'selected') {
					autoGeneratedScenarioBlocks = false;					
				}

				if (element === scenarioTab)
					runCodeForScenario(element);
			}

      		if (entityWorkspace !== undefined) {
				entityWorkspace.addChangeListener(onEntityWorkspaceChange);
			}

      		if (scenarioWorkspace !== undefined) {
				scenarioWorkspace.addChangeListener(onScenarioWorkspaceChange);
			}
		})
}

function filterCategories(element, contents) {
	if (element === entitiesTab) {
		let categories = ["Declarative Scenarios", "Imperative Scenarios"];
		return contents.filter(item => !categories.includes(item.name));
	}
	else if (element === scenarioTab) {
		let categories = ["Declarative Entities", "Imperative Entities"];
		return contents.filter(item => !categories.includes(item.name));
	}
}

function saveScenario() {
  const scenarioEditor = ace.edit("xtext-editor-scenarios");
  const scenarioContent = scenarioEditor.getValue();

  appendToConsole(`${scenarioContent}!\n`);

  // Save the scenario content
  fetch('/save-scenario', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: scenarioContent })
  })
  .then(response => {
    if (response.ok) {
      appendToConsole('Scenario saved successfully!\n');
    } else {
      appendToConsole('Error saving scenario.\n');
    }
  })
  .catch(error => {
    appendToConsole('Error: An error occurred while saving the scenario.\n');
  });
}

function saveEntities() {
  const entitiesEditor = ace.edit("xtext-editor-entities");
  const entitiesContent = entitiesEditor.getValue();
  
  appendToConsole(`${entitiesContent}!\n`);

  // Save the entities content
  fetch('/save-entities', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: entitiesContent })
  })
  .then(response => {
    if (response.ok) {
      appendToConsole('Entities saved successfully!\n');
    } else {
      appendToConsole('Error saving entities.\n');
    }
  })
  .catch(error => {
    appendToConsole('Error: An error occurred while saving the entities.\n');
  });
}


/*
function runScenario() {
  fetch('/run-scenario', {
    method: 'POST',
  }).then(response => {
    if (response.ok) {
      alert('Scenario running...');
    } else {
      alert('Error running scenario.');
    }
  });
}*/

function runScenario() {
	// Establish a connection to the backend SSE servlet
    const eventSource = new EventSource('/run-scenario');
	
	// Listen for incoming messages
	eventSource.onmessage = function(event) {
	    // Append received message to the messages div
	    /*const messagesDiv = document.getElementById('messages');
	    const newMessage = document.createElement('p');
	    newMessage.textContent = event.data;
	    messagesDiv.appendChild(newMessage);*/
		console.log(event.data);
	};
	
	// Handle any errors in the connection
	eventSource.onerror = function(event) {
		eventSource.close();
	};
}

document.addEventListener('DOMContentLoaded', function() {
    // Initialize console
    const consoleOutput = document.getElementById('console-output');
    const clearConsoleButton = document.getElementById('clear-console');

    // Clear console button functionality
    clearConsoleButton.addEventListener('click', function() {
        consoleOutput.textContent = '';
    });

    // Add initial message
    appendToConsole('Console ready. Click "Run Scenario" to begin.\n');
});

function appendToConsole(message) {
    const consoleOutput = document.getElementById('console-output');
    consoleOutput.textContent += message;
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
}

function runScenario() {
    const consoleOutput = document.getElementById('console-output');
    consoleOutput.textContent = ''; // Clear previous output
    appendToConsole('Starting scenario execution...\n');

    const eventSource = new EventSource('/console-output');

    eventSource.onmessage = function(event) {
        appendToConsole(event.data + '\n');
    };

    eventSource.onerror = function() {
        appendToConsole('Error: Connection to server lost\n');
        eventSource.close();
    };

    eventSource.addEventListener('close', function(event) {
        appendToConsole('Execution completed\n');
        eventSource.close();
    });
}

document.addEventListener('DOMContentLoaded', function() {
		(function() {
		  // Existing Console Resizing
		  const consoleDragHandle = document.getElementById('drag-handle');
		  const consoleSection = document.getElementById('console-section');

		  let isConsoleDragging = false;
		  let consoleStartY = 0;
		  let consoleStartHeight = 0;

		  consoleDragHandle.addEventListener('mousedown', function(e) {
		    isConsoleDragging = true;
		    consoleStartY = e.clientY;
		    consoleStartHeight = consoleSection.getBoundingClientRect().height;
		    document.body.style.cursor = 'ns-resize';
		    document.body.style.userSelect = 'none';
		  });

		  document.addEventListener('mousemove', function(e) {
		    if (!isConsoleDragging) return;
		    const dy = e.clientY - consoleStartY;
		    let newHeight = consoleStartHeight - dy;
		    const minHeight = 100; // Minimum console height in px
		    const maxHeight = window.innerHeight - 200; // Maximum console height
		    if (newHeight < minHeight) newHeight = minHeight;
		    if (newHeight > maxHeight) newHeight = maxHeight;
		    consoleSection.style.height = newHeight + 'px';
		  });

		  document.addEventListener('mouseup', function(e) {
		    if (isConsoleDragging) {
		      isConsoleDragging = false;
		      document.body.style.cursor = 'default';
		      document.body.style.userSelect = 'auto';
		    }
		  });

		  const verticalDragHandle = document.getElementById('vertical-drag-handle');
		  const xtextWrapper = document.querySelector('.xtext-wrapper');
		  const blocklyEditor = document.getElementById('blockly-editor');

		  let isVerticalDragging = false;
		  let verticalStartX = 0;
		  let xtextStartWidth = 0;
		  let blocklyStartWidth = 0;

		  verticalDragHandle.addEventListener('mousedown', function(e) {
		    isVerticalDragging = true;
		    verticalStartX = e.clientX;
		    xtextStartWidth = xtextWrapper.getBoundingClientRect().width;
		    blocklyStartWidth = blocklyEditor.getBoundingClientRect().width;
		    document.body.style.cursor = 'ew-resize';
		    document.body.style.userSelect = 'none';
		  });

		  document.addEventListener('mousemove', function(e) {
		    if (!isVerticalDragging) return;
		    const dx = e.clientX - verticalStartX;
		    let newXtextWidth = xtextStartWidth + dx;
		    let newBlocklyWidth = blocklyStartWidth - dx;

		    const minWidth = 150; // Minimum width for editors

		    // Ensure minimum widths
		    if (newXtextWidth < minWidth) {
		      newXtextWidth = minWidth;
		      newBlocklyWidth = xtextStartWidth + blocklyStartWidth - minWidth;
		    }
		    if (newBlocklyWidth < minWidth) {
		      newBlocklyWidth = minWidth;
		      newXtextWidth = xtextStartWidth + blocklyStartWidth - minWidth;
		    }

		    // Use flex-basis instead of width
		    xtextWrapper.style.flexBasis = `${newXtextWidth}px`;
		    blocklyEditor.style.flexBasis = `${newBlocklyWidth}px`;

		    Blockly.svgResize(Blockly.getMainWorkspace());
		  });

		  document.addEventListener('mouseup', function(e) {
		    if (isVerticalDragging) {
		      isVerticalDragging = false;
		      document.body.style.cursor = 'default';
		      document.body.style.userSelect = 'auto';
		    }
		  });

		  document.addEventListener('mouseup', function(e) {
		    if (isVerticalDragging) {
		      isVerticalDragging = false;
		      document.body.style.cursor = 'default';
		      document.body.style.userSelect = 'auto';
		    }
		  });

		  // Optional: Adjust editor widths on window resize to maintain layout
		  window.addEventListener('resize', function() {
		    const totalWidth = xtextWrapper.getBoundingClientRect().width + blocklyEditor.getBoundingClientRect().width + verticalDragHandle.getBoundingClientRect().width;
		    const containerWidth = document.querySelector('.editors-section').getBoundingClientRect().width;

		    if (totalWidth > containerWidth) {
		      // Adjust widths proportionally
		      const excessWidth = totalWidth - containerWidth;
		      let newXtextWidth = xtextWrapper.getBoundingClientRect().width - (excessWidth / 2);
		      let newBlocklyWidth = blocklyEditor.getBoundingClientRect().width - (excessWidth / 2);

		      const minWidth = 150;
		      if (newXtextWidth < minWidth) newXtextWidth = minWidth;
		      if (newBlocklyWidth < minWidth) newBlocklyWidth = minWidth;

		      xtextWrapper.style.width = newXtextWidth + 'px';
		      blocklyEditor.style.width = newBlocklyWidth + 'px';
		    }
		  });
		})();

          initializeVersionControl();
      });

	  
	  function toggleVersionPanel() {
	    const panel = document.querySelector('.version-control-panel');
	    panel.classList.toggle('collapsed');

	  }

      function initializeVersionControl() {
          document.getElementById('save-version').addEventListener('click', saveVersion);
          listVersions();
      }

      async function listVersions() {
          try {
              const response = await fetch('/list-versions');
              const versions = await response.json();
              
              const versionsContainer = document.getElementById('versions-list');
              versionsContainer.innerHTML = '';
              
              versions.forEach(version => {
                  const versionElement = createVersionElement(version);
                  versionsContainer.appendChild(versionElement);
              });
              
              appendToConsole("Versions loaded successfully.\n");
          } catch (error) {
              appendToConsole(`Error loading versions: ${error.message}\n`);
          }
      }

      function createVersionElement(version) {
		let dateString = version.metadata?.createdAt;
		if (!dateString) {
		    dateString = version.metadata?.timestamp;
		    if(dateString){
		        // Parse the custom timestamp string into a Date object
		        const year = parseInt(dateString.substring(0, 4));
		        const month = parseInt(dateString.substring(4, 6)) - 1; // Month is 0-indexed
		        const day = parseInt(dateString.substring(6, 8));
		        const hour = parseInt(dateString.substring(9, 11));
		        const minute = parseInt(dateString.substring(11, 13));
		        const second = parseInt(dateString.substring(13, 15));
		        dateString = new Date(year, month, day, hour, minute, second).toISOString();
		    } else {
		        dateString = version.lastModified;  // Fallback if both custom and createdAt are missing
		    }
		}
		const date = new Date(dateString); // Create date object once

		const fileName = version.metadata?.fileName || 'Unnamed';
		const folderName = version.folderName || 'Unversioned';

          const versionDiv = document.createElement('div');
          versionDiv.className = 'version-item';
          versionDiv.dataset.version = version.folderName;
          
          versionDiv.innerHTML = `
              <div class="version-item-header">
                  <div class="version-info">
                      <div class="version-name">${fileName}</div>
                      <div class="version-timestamp">
                          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <circle cx="12" cy="12" r="10"/>
                              <path d="M12 6v6l4 2"/>
                          </svg>
                          ${date.toLocaleString()}
                      </div>
                  </div>
                  <div class="version-actions">
                      <button onclick="revertToVersion('${version.folderName}')">
                          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                              <path d="M3 3v5h5"/>
                          </svg>
                          Revert
                      </button>
                  </div>
              </div>
          `;
          
          return versionDiv;
      }

	  async function revertToVersion(versionFileName) {
	      if (!versionFileName) {
	          appendToConsole("No version selected for revert.\n");
	          return;
	      }

	      try {
	          const response = await fetch('/revert-version', {
	              method: 'POST',
	              headers: {
	                  'Content-Type': 'application/json'
	              },
	              body: JSON.stringify({ versionFileName })
	          });

	          const result = await response.json();

	          if (response.ok) {
	              appendToConsole(`Reverted to version: ${versionFileName}\n`);
	              
	              if (result.contentScenario && result.contentEntities) {
	                  const editorScenario = getScenarioAceEditor();
	                  editorScenario.setValue(result.contentScenario);
	                  editorScenario.clearSelection();

	                  const editorEntities = getEntitiesAceEditor();
	                  editorEntities.setValue(result.contentEntities);
	                  editorEntities.clearSelection();
	              }
	              
	              document.querySelectorAll('.version-item').forEach(item => {
	                  item.classList.remove('selected');
	                  if (item.dataset.version === versionFileName) {
	                      item.classList.add('selected');
	                  }
	              });
	              
	              await listVersions();
	          } else {
	              appendToConsole(`Failed to revert to version: ${result.message}\n`);
	          }
	      } catch (error) {
	          appendToConsole(`Error reverting version: ${error.message}\n`);
	      }
	  }

	  async function saveVersion() {
	      const editorScenario = getScenarioAceEditor(); // Function to get scenario editor
	      const contentScenario = editorScenario.getValue();
	      
	      const editorEntities = getEntitiesAceEditor(); // Function to get entities editor
	      const contentEntities = editorEntities.getValue();
	      
	      const metadata = {
	          fileName: document.getElementById("fileName").value || 'Unnamed Scenario',
	          timestamp: new Date().toISOString()
	      };
		  const payload = { contentScenario, contentEntities, metadata }; // Prepare payload

		  // Log the payload to the console
		  console.log("Payload to /save-both:", JSON.stringify(payload, null, 2));
		  appendToConsole(`Payload to be sent: ${JSON.stringify(payload, null, 2)}\n`);

		  try {
		      const response = await fetch('/save-both', {
		          method: 'POST',
		          headers: {
		              'Content-Type': 'application/json'
		          },
		          body: JSON.stringify(payload)
		      });

		      if (response.ok) {
		          const result = await response.json();
		          appendToConsole(`Version saved successfully: ${result.version}\n`);
		          await listVersions();
		      } else {
		          const error = await response.text();
		          appendToConsole(`Failed to save version: ${error}\n`);
		      }
		  } catch (error) {
		      appendToConsole(`Error: ${error.message}\n`);
		  }
	  }
	  function getScenarioAceEditor() {
		return ace.edit("xtext-editor-scenarios");
	  }

	  function getEntitiesAceEditor() {
		return ace.edit("xtext-editor-entities"); 
	  }

